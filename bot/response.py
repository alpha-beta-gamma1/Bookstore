from typing import Dict, List, Optional
from bot.db import Database
from bot.dialog_manager import DialogManager
from bot.nlu import NLU
import unicodedata
import re

class ResponseGenerator:
    def __init__(self):
        self.db = Database()
        self.dialog_manager = DialogManager()
        self.nlu = NLU()

    def generate_response(self, session_id: str, user_message: str) -> str:
        """T·∫°o ph·∫£n h·ªìi cho ng∆∞·ªùi d√πng v·ªõi h·ªó tr·ª£ ƒë·∫∑t nhi·ªÅu s√°ch"""
        msg_lower = user_message.lower().strip()

        # NLU: ph√¢n t√≠ch intent v√† entities
        intent, _ = self.nlu.classify_intent(user_message)
        entities_result = self.nlu.analyze(user_message)
        entities = entities_result.get('entities', {}) if isinstance(entities_result, dict) else {}

        # L·∫•y tr·∫°ng th√°i hi·ªán t·∫°i
        state = self.dialog_manager.get_state(session_id)
        context = self.dialog_manager.get_context(session_id) or {}

        print(f"Intent: {intent} , Entities: {entities}, State: {state}")

        # N·∫øu ƒëang trong order flow
        if state and state.startswith('order_'):
            exit_keywords = ['h·ªßy', 'th√¥i', 'kh√¥ng mua', 'd·ª´ng', 'stop', 'cancel', 't·∫°m bi·ªát', 'bye']
            if any(word in msg_lower for word in exit_keywords):
                self.dialog_manager.clear_session(session_id)
                return "ƒê√£ h·ªßy ƒë·∫∑t h√†ng. B·∫°n c·∫ßn g√¨ kh√°c kh√¥ng ·∫°?"

            if intent == 'thanks' or any(k in msg_lower for k in ['c·∫£m ∆°n', 'thank you']):
                return "R·∫•t vui ƒë∆∞·ª£c gi√∫p ƒë·ª° b·∫°n! B·∫°n c√≤n c·∫ßn g√¨ cho ƒë∆°n h√†ng kh√¥ng ·∫°?"

            response = self._handle_order_flow(session_id, user_message, state, context, entities)
        else:
            # Kh√¥ng trong order flow
            if intent == 'greeting':
                response = self._handle_greeting()
            elif intent == 'search_book':
                response = self._handle_search_book(entities)
            elif intent == 'order_book':
                # üî• FIX: X·ª≠ l√Ω c·∫£ ƒë∆°n s√°ch v√† nhi·ªÅu s√°ch
                response = self._handle_start_order(session_id, user_message, entities)
            elif intent == 'list_books':
                response = self._handle_list_books()
            elif intent == 'thanks':
                response = "R·∫•t vui ƒë∆∞·ª£c gi√∫p ƒë·ª° b·∫°n! N·∫øu c·∫ßn th√™m g√¨, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi nh√©!"
            elif intent == 'bye':
                response = "T·∫°m bi·ªát! H·∫πn g·∫∑p l·∫°i b·∫°n!"
            else:
                response = self._handle_unknown()

        try:
            self.db.save_conversation(session_id, user_message, response, intent)
        except Exception as e:
            print(f"Warning: L∆∞u l·ªãch s·ª≠ th·∫•t b·∫°i: {e}")

        return response

    # ---------------- Handlers c∆° b·∫£n ----------------
    def _handle_greeting(self) -> str:
        return ("Xin ch√†o! üëã T√¥i l√† tr·ª£ l√Ω c·ªßa BookStore.\n"
                "T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n"
                "‚Ä¢ T√¨m s√°ch: 'T√¨m s√°ch [t√™n s√°ch]'\n"
                "‚Ä¢ ƒê·∫∑t s√°ch: 'T√¥i mu·ªën mua [t√™n s√°ch]'\n"
                "‚Ä¢ ƒê·∫∑t nhi·ªÅu s√°ch: 'Mua 2 ƒë·∫Øc nh√¢n t√¢m v√† 3 nh√† gi·∫£ kim'\n"
                "‚Ä¢ Xem danh s√°ch: 'C√≥ nh·ªØng s√°ch g√¨'\n"
                "B·∫°n c·∫ßn g√¨ ·∫°?")

    def _handle_search_book(self, entities: Dict) -> str:
        book_title = entities.get('book_title') or ''
        keyword = str(book_title).strip() if book_title else ''
        if not keyword:
            return "B·∫°n mu·ªën t√¨m s√°ch g√¨ ·∫°? Vui l√≤ng cho bi·∫øt t√™n s√°ch."

        books = self.db.search_books(keyword)
        if not books:
            return (f"Xin l·ªói, t√¥i kh√¥ng t√¨m th·∫•y s√°ch n√†o v·ªõi t·ª´ kh√≥a '{keyword}'. "
                    f"B·∫°n c√≥ th·ªÉ xem danh s√°ch s√°ch b·∫±ng c√°ch h·ªèi 'C√≥ nh·ªØng s√°ch g√¨?'")

        if len(books) == 1:
            book = books[0]
            return (f"üìö **{book['title']}**\n"
                    f"üë§ T√°c gi·∫£: {book['author']}\n"
                    f"üí∞ Gi√°: {book['price']:,.0f}ƒë\n"
                    f"üì¶ C√≤n l·∫°i: {book['stock']} cu·ªën\n"
                    f"üè∑Ô∏è Th·ªÉ lo·∫°i: {book['category']}\n\n"
                    f"N·∫øu mu·ªën ƒë·∫∑t mua, b·∫°n c√≥ th·ªÉ n√≥i 'T√¥i mu·ªën mua {book['title']}'")
        else:
            short_list = books[:10]
            candidates = {str(i+1): book['id'] for i, book in enumerate(short_list)}
            ctx = {'candidates': candidates, 'candidate_list_preview': short_list}

            response = f"T√¥i t√¨m th·∫•y {len(books)} k·∫øt qu·∫£. Vui l√≤ng ch·ªçn s·ªë t∆∞∆°ng ·ª©ng (1-{len(short_list)}) ho·∫∑c vi·∫øt r√µ t√™n s√°ch:\n\n"
            for i, book in enumerate(short_list, 1):
                response += (f"{i}. **{book['title']}** - {book['author']} | Gi√°: {book['price']:,.0f}ƒë | C√≤n: {book['stock']}\n")
            if len(books) > len(short_list):
                response += f"\n... v√† {len(books) - len(short_list)} k·∫øt qu·∫£ kh√°c."
            response += "\n\nB·∫°n ch·ªçn s·ªë m·∫•y?"
            
            self.dialog_manager.update_session(session_id, state='order_choose_book', context=ctx)
            return response

    def _handle_list_books(self) -> str:
        books = self.db.get_all_books()
        if not books:
            return "Hi·ªán t·∫°i c·ª≠a h√†ng ch∆∞a c√≥ s√°ch n√†o."

        response = "üìö **DANH S√ÅCH S√ÅCH C·ª¶A C·ª¨A H√ÄNG:**\n\n"
        for book in books[:10]:
            response += (f"‚Ä¢ **{book['title']}**\n"
                         f"  T√°c gi·∫£: {book['author']} | Gi√°: {book['price']:,.0f}ƒë | C√≤n: {book['stock']} cu·ªën\n\n")

        if len(books) > 10:
            response += f"\n... v√† {len(books) - 10} cu·ªën s√°ch kh√°c."

        return response

    # ---------------- üî• FIX: X·ª≠ l√Ω ƒë·∫∑t h√†ng nhi·ªÅu s√°ch ----------------
    def _handle_start_order(self, session_id: str, user_message: str, entities: Dict) -> str:
        """X·ª≠ l√Ω ƒë·∫∑t h√†ng - h·ªó tr·ª£ c·∫£ 1 s√°ch v√† nhi·ªÅu s√°ch"""
        
        # üî• Case 1: Nhi·ªÅu s√°ch (books array)
        if 'books' in entities and isinstance(entities['books'], list):
            return self._handle_multi_book_order(session_id, entities)
        
        # üî• Case 2: M·ªôt s√°ch (book_title)
        book_title = entities.get('book_title') or ''
        keyword = str(book_title).strip() if book_title else ''
        if not keyword:
            return "B·∫°n mu·ªën mua s√°ch g√¨ ·∫°? Vui l√≤ng cho bi·∫øt t√™n s√°ch."

        books = self.db.search_books(keyword)

        if not books:
            return f"Xin l·ªói, t√¥i kh√¥ng t√¨m th·∫•y s√°ch '{keyword}'. Vui l√≤ng ki·ªÉm tra l·∫°i t√™n s√°ch."

        if len(books) > 1:
            return self._handle_search_book({'book_title': keyword})

        # 1 k·∫øt qu·∫£
        book = books[0]
        if book['stock'] == 0:
            return f"Xin l·ªói, s√°ch '{book['title']}' hi·ªán ƒë√£ h·∫øt h√†ng."

        # Chu·∫©n h√≥a v√† validate
        quantity = self._normalize_and_validate_quantity(entities.get('quantity'), book['stock'])
        customer_name = self._validate_name(entities.get('customer_name'))
        phone = self._validate_phone(entities.get('phone'))
        address = self._validate_address(entities.get('address'))

        context = {
            'order_type': 'single',  # ƒê√°nh d·∫•u ƒë∆°n s√°ch ƒë∆°n
            'book_id': book['book_id'],
            'book_title': book['title'],
            'book_price': book['price'],
            'book_stock': book['stock'],
            'quantity': quantity,
            'customer_name': customer_name,
            'phone': phone,
            'address': address
        }

        return self._proceed_to_next_step(session_id, context)

    def _handle_multi_book_order(self, session_id: str, entities: Dict) -> str:
        """üî• X·ª¨ L√ù ƒê·∫∂T NHI·ªÄU S√ÅCH C√ôNG L√öC"""
        books_data = entities['books']
        
        # Validate v√† chu·∫©n b·ªã th√¥ng tin c√°c s√°ch
        order_items = []
        total_price = 0
        errors = []
        
        for item in books_data:
            title = item.get('title', '').strip()
            qty = item.get('quantity', 1)
            
            if not title:
                continue
                
            # T√¨m s√°ch trong DB
            books = self.db.search_books(title)
            
            if not books:
                errors.append(f"‚ùå Kh√¥ng t√¨m th·∫•y s√°ch '{title}'")
                continue
            
            if len(books) > 1:
                errors.append(f"‚ö†Ô∏è T√¨m th·∫•y nhi·ªÅu k·∫øt qu·∫£ cho '{title}', vui l√≤ng ch·ªçn r√µ h∆°n")
                continue
            
            book = books[0]
            
            # Validate s·ªë l∆∞·ª£ng
            qty_validated = self._normalize_and_validate_quantity(qty, book['stock'])
            if qty_validated is None:
                errors.append(f"‚ùå S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá cho '{book['title']}' (c√≤n {book['stock']} cu·ªën)")
                continue
            
            order_items.append({
                'book_id': book['book_id'],
                'title': book['title'],
                'price': book['price'],
                'stock': book['stock'],
                'quantity': qty_validated
            })
            total_price += book['price'] * qty_validated
        
        # Ki·ªÉm tra c√≥ s√°ch h·ª£p l·ªá kh√¥ng
        if not order_items:
            error_msg = "Kh√¥ng th·ªÉ x·ª≠ l√Ω ƒë∆°n h√†ng:\n" + "\n".join(errors)
            return error_msg
        
        # Hi·ªÉn th·ªã th√¥ng b√°o l·ªói n·∫øu c√≥
        warning = ""
        if errors:
            warning = "**L∆ØU √ù:**\n" + "\n".join(errors) + "\n\n"
        
        # L∆∞u context cho ƒë∆°n h√†ng nhi·ªÅu s√°ch
        context = {
            'order_type': 'multi',
            'order_items': order_items,
            'total_price': total_price,
            'customer_name': entities.get('customer_name'),
            'phone': entities.get('phone'),
            'address': entities.get('address')
        }
        
        # üî• FIX: Kh√¥ng th√™m summary ·ªü ƒë√¢y n·ªØa, ƒë·ªÉ _proceed_to_next_step x·ª≠ l√Ω
        return (warning if warning else "") + self._proceed_to_next_step(session_id, context)

    def _proceed_to_next_step(self, session_id: str, context: dict) -> str:
        """Ki·ªÉm tra th√¥ng tin c√≤n thi·∫øu v√† chuy·ªÉn ƒë·∫øn b∆∞·ªõc ti·∫øp theo"""
        required_fields = ['customer_name', 'phone', 'address']
        
        # ƒê·ªëi v·ªõi ƒë∆°n s√°ch ƒë∆°n, c·∫ßn c·∫£ quantity
        if context.get('order_type') == 'single':
            required_fields.insert(0, 'quantity')
        
        missing = [f for f in required_fields if not context.get(f)]
        
        print(f"DEBUG - Missing fields: {missing}")
        
        if missing:
            next_field = missing[0]
            next_state = f'order_ask_{next_field}'
            self.dialog_manager.update_session(session_id, state=next_state, context=context)
            
            # üî• FIX: Hi·ªÉn th·ªã summary tr∆∞·ªõc c√¢u h·ªèi cho ƒë∆°n nhi·ªÅu s√°ch
            prefix = ""
            if context.get('order_type') == 'multi' and next_field == 'customer_name':
                prefix = self._format_order_summary(context) + "\n\n"
            
            questions = {
                'quantity': f"B·∫°n mu·ªën mua m·∫•y cu·ªën ·∫°? (C√≤n l·∫°i: {context.get('book_stock', 0)} cu·ªën)",
                'customer_name': "M√¨nh c√≥ th·ªÉ bi·∫øt t√™n c·ªßa b·∫°n kh√¥ng?",
                'phone': "B·∫°n cho m√¨nh xin s·ªë ƒëi·ªán tho·∫°i ƒë·ªÉ li√™n h·ªá nh√©?",
                'address': "B·∫°n vui l√≤ng cung c·∫•p ƒë·ªãa ch·ªâ giao h√†ng?"
            }
            return prefix + questions[next_field]
        else:
            # ƒê·ªß th√¥ng tin -> x√°c nh·∫≠n
            return self._generate_order_confirmation(session_id, context)
    
    def _format_order_summary(self, context: dict) -> str:
        """Format summary cho ƒë∆°n nhi·ªÅu s√°ch"""
        if context.get('order_type') != 'multi':
            return ""
        
        summary = "üìã **ƒê∆†N H√ÄNG C·ª¶A B·∫†N:**\n\n"
        for i, item in enumerate(context['order_items'], 1):
            subtotal = item['price'] * item['quantity']
            summary += f"{i}. **{item['title']}** x{item['quantity']} = {subtotal:,.0f}ƒë\n"
        
        summary += f"\nüí∞ **T·ªïng c·ªông: {context['total_price']:,.0f}ƒë**"
        return summary

    def _generate_order_confirmation(self, session_id: str, context: dict) -> str:
        """T·∫°o th√¥ng b√°o x√°c nh·∫≠n ƒë∆°n h√†ng"""
        self.dialog_manager.update_session(session_id, state='order_confirm', context=context)
        
        if context.get('order_type') == 'multi':
            # ƒê∆°n nhi·ªÅu s√°ch
            items_text = ""
            for i, item in enumerate(context['order_items'], 1):
                subtotal = item['price'] * item['quantity']
                items_text += f"  {i}. {item['title']} x{item['quantity']} = {subtotal:,.0f}ƒë\n"
            
            return (f"üìã **X√ÅC NH·∫¨N ƒê√îN H√ÄNG:**\n\n"
                    f"üìö S√°ch:\n{items_text}\n"
                    f"üí∞ T·ªïng ti·ªÅn: {context['total_price']:,.0f}ƒë\n"
                    f"üë§ Ng∆∞·ªùi nh·∫≠n: {context['customer_name']}\n"
                    f"üìû SƒêT: {context['phone']}\n"
                    f"üìç ƒê·ªãa ch·ªâ: {context['address']}\n\n"
                    f"G√µ 'x√°c nh·∫≠n' ƒë·ªÉ ho√†n t·∫•t ƒë·∫∑t h√†ng, 's·ª≠a <tr∆∞·ªùng>' ƒë·ªÉ ch·ªânh, ho·∫∑c 'h·ªßy' ƒë·ªÉ h·ªßy b·ªè.")
        else:
            # ƒê∆°n s√°ch ƒë∆°n
            total = context['book_price'] * context['quantity']
            return (f"üìã **X√ÅC NH·∫¨N ƒê∆†N H√ÄNG:**\n\n"
                    f"üìö S√°ch: {context['book_title']}\n"
                    f"üî¢ S·ªë l∆∞·ª£ng: {context['quantity']} cu·ªën\n"
                    f"üí∞ T·ªïng ti·ªÅn: {total:,.0f}ƒë\n"
                    f"üë§ Ng∆∞·ªùi nh·∫≠n: {context['customer_name']}\n"
                    f"üìû SƒêT: {context['phone']}\n"
                    f"üìç ƒê·ªãa ch·ªâ: {context['address']}\n\n"
                    f"G√µ 'x√°c nh·∫≠n' ƒë·ªÉ ho√†n t·∫•t ƒë·∫∑t h√†ng, 's·ª≠a <tr∆∞·ªùng>' ƒë·ªÉ ch·ªânh, ho·∫∑c 'h·ªßy' ƒë·ªÉ h·ªßy b·ªè.")

    # ---------------- Lu·ªìng ƒë·∫∑t h√†ng chi ti·∫øt ----------------
    def _handle_order_flow(self, session_id: str, message: str, state: str, context: Dict, entities: Dict = None) -> str:
        """X·ª≠ l√Ω t·ª´ng b∆∞·ªõc c·ªßa lu·ªìng ƒë·∫∑t h√†ng"""
        msg_lower = message.lower()
        intent, _ = self.nlu.classify_intent(message)
        
        if entities is None:
            entities_res = self.nlu.analyze(message)
            entities = entities_res.get('entities', {}) if isinstance(entities_res, dict) else {}

        # Ch·ªçn s√°ch t·ª´ danh s√°ch t·∫°m
        if state == 'order_choose_book':
            candidates = context.get('candidates') if context else None
            if not candidates:
                self.dialog_manager.clear_session(session_id)
                return "Xin l·ªói, danh s√°ch l·ª±a ch·ªçn ƒë√£ h·∫øt h·∫°n. B·∫°n vui l√≤ng t√¨m l·∫°i s√°ch nh√©."

            idx_match = re.search(r'\b(\d{1,2})\b', message)
            if idx_match:
                idx = idx_match.group(1)
                book_id = candidates.get(idx)
                if book_id:
                    book = self.db.get_book_by_id(book_id)
                    if not book:
                        return "Kh√¥ng t√¨m th·∫•y s√°ch ƒë√£ ch·ªçn, vui l√≤ng th·ª≠ l·∫°i."
                    
                    new_context = {
                        'order_type': 'single',
                        'book_id': book['book_id'],
                        'book_title': book['title'],
                        'book_price': book['price'],
                        'book_stock': book['stock'],
                        'quantity': None,
                        'customer_name': None,
                        'phone': None,
                        'address': None
                    }
                    return self._proceed_to_next_step(session_id, new_context)
                else:
                    return "S·ªë b·∫°n ch·ªçn kh√¥ng c√≥ trong danh s√°ch, vui l√≤ng ch·ªçn l·∫°i."
            else:
                preview = context.get('candidate_list_preview', [])
                for b in preview:
                    if message.strip().lower() in b['title'].lower():
                        new_context = {
                            'order_type': 'single',
                            'book_id': b['book_id'],
                            'book_title': b['title'],
                            'book_price': b['price'],
                            'book_stock': b['stock'],
                            'quantity': None,
                            'customer_name': None,
                            'phone': None,
                            'address': None
                        }
                        return self._proceed_to_next_step(session_id, new_context)
                return "M√¨nh kh√¥ng hi·ªÉu l·ª±a ch·ªçn c·ªßa b·∫°n ‚Äì vui l√≤ng ch·ªçn theo s·ªë (v√≠ d·ª•: 1) ho·∫∑c vi·∫øt r√µ t√™n s√°ch."

        # C√°c b∆∞·ªõc h·ªèi th√¥ng tin
        new_context = dict(context)

        if state == 'order_ask_quantity':
            qty_raw = entities.get('quantity') or self._extract_quantity_from_message(message, context['book_stock'])
            if qty_raw is None:
                return f"B·∫°n mu·ªën mua bao nhi√™u cu·ªën? (C√≤n l·∫°i: {context['book_stock']} cu·ªën)"

            qty = self._normalize_and_validate_quantity(qty_raw, context['book_stock'])
            if qty is None:
                return f"S·ªë l∆∞·ª£ng b·∫°n nh·∫≠p ({qty_raw}) v∆∞·ª£t qu√° t·ªìn kho ({context['book_stock']} cu·ªën). Vui l√≤ng ch·ªçn l·∫°i."

            new_context['quantity'] = qty
            return self._proceed_to_next_step(session_id, new_context)

        elif state == 'order_ask_customer_name':
            name = self._validate_name(entities.get('customer_name') or message.strip())
            if not name:
                return "T√™n qu√° ng·∫Øn, b·∫°n nh·∫≠p l·∫°i gi√∫p m√¨nh nh√©!"

            new_context['customer_name'] = name
            return self._proceed_to_next_step(session_id, new_context)

        elif state == 'order_ask_phone':
            phone = self._validate_phone(entities.get('phone') or self._extract_phone_from_message(message))
            if not phone:
                return "S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá, vui l√≤ng nh·∫≠p l·∫°i (10-11 s·ªë)."

            new_context['phone'] = phone
            return self._proceed_to_next_step(session_id, new_context)

        elif state == 'order_ask_address':
            address = self._validate_address(entities.get('address') or message.strip())
            if not address:
                return "ƒê·ªãa ch·ªâ h∆°i ng·∫Øn, b·∫°n nh·∫≠p chi ti·∫øt h∆°n nh√©!"

            new_context['address'] = address
            return self._proceed_to_next_step(session_id, new_context)

        elif state == 'order_confirm':
            # X·ª≠ l√Ω s·ª≠a th√¥ng tin
            edit_match = re.search(r"s·ª≠a\s+(s·ªë l∆∞·ª£ng|sl|sƒët|sdt|s·ªë ƒëi·ªán tho·∫°i|ƒë·ªãa ch·ªâ|t√™n)\s*(.*)", message.lower())
            if edit_match:
                return self._handle_edit_field(session_id, context, edit_match)

            # X√°c nh·∫≠n ƒë∆°n
            if intent == "confirm_order" or any(word in msg_lower for word in ["x√°c nh·∫≠n", "xac nhan", "ok", "ƒë·ªìng √Ω", "dong y"]):
                return self._finalize_order(session_id, context)

            if any(k in msg_lower for k in ['s·ª≠a', 'thay', 'ƒë·ªïi']):
                return "B·∫°n mu·ªën s·ª≠a tr∆∞·ªùng n√†o? (s·ªë l∆∞·ª£ng, t√™n, sƒët, ƒë·ªãa ch·ªâ) ‚Äì v√≠ d·ª•: 's·ª≠a s·ªë l∆∞·ª£ng 2'"

            return "Vui l√≤ng g√µ 'x√°c nh·∫≠n' ƒë·ªÉ ho√†n t·∫•t ho·∫∑c 's·ª≠a <tr∆∞·ªùng>' ƒë·ªÉ ch·ªânh th√¥ng tin, 'h·ªßy' ƒë·ªÉ hu·ª∑ ƒë∆°n."

        return "C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i."

    def _handle_edit_field(self, session_id: str, context: dict, edit_match) -> str:
        """X·ª≠ l√Ω ch·ªânh s·ª≠a th√¥ng tin ƒë∆°n h√†ng"""
        field = edit_match.group(1)
        rest = edit_match.group(2).strip()
        
        if field in ['s·ªë l∆∞·ª£ng', 'sl'] and context.get('order_type') == 'single':
            new_qty = self._normalize_and_validate_quantity(rest or None, context['book_stock']) or self._extract_quantity_from_message(rest or '', context['book_stock'])
            if not new_qty:
                return f"S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá ho·∫∑c v∆∞·ª£t qu√° t·ªìn kho ({context['book_stock']}), vui l√≤ng nh·∫≠p l·∫°i."
            context['quantity'] = new_qty
            self.dialog_manager.update_session(session_id, state='order_confirm', context=context)
            total = context['quantity'] * context['book_price']
            return f"ƒê√£ c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng th√†nh {new_qty}. T·ªïng ti·ªÅn m·ªõi: {total:,.0f}ƒë. G√µ 'x√°c nh·∫≠n' ƒë·ªÉ ho√†n t·∫•t."
        
        if field in ['sƒët', 'sdt', 's·ªë ƒëi·ªán tho·∫°i']:
            phone = self._validate_phone(rest)
            if not phone:
                return "S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá (10-11 ch·ªØ s·ªë)."
            context['phone'] = phone
            self.dialog_manager.update_session(session_id, state='order_confirm', context=context)
            return "ƒê√£ c·∫≠p nh·∫≠t s·ªë ƒëi·ªán tho·∫°i. Vui l√≤ng g√µ 'x√°c nh·∫≠n' ƒë·ªÉ ho√†n t·∫•t."
        
        if field == 'ƒë·ªãa ch·ªâ':
            addr = self._validate_address(rest or '')
            if not addr:
                return "ƒê·ªãa ch·ªâ qu√° ng·∫Øn, vui l√≤ng nh·∫≠p chi ti·∫øt h∆°n."
            context['address'] = addr
            self.dialog_manager.update_session(session_id, state='order_confirm', context=context)
            return "ƒê√£ c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ. Vui l√≤ng g√µ 'x√°c nh·∫≠n' ƒë·ªÉ ho√†n t·∫•t."
        
        if field == 't√™n':
            name = self._validate_name(rest or '')
            if not name:
                return "T√™n qu√° ng·∫Øn, vui l√≤ng nh·∫≠p l·∫°i."
            context['customer_name'] = name
            self.dialog_manager.update_session(session_id, state='order_confirm', context=context)
            return "ƒê√£ c·∫≠p nh·∫≠t t√™n ng∆∞·ªùi nh·∫≠n. Vui l√≤ng g√µ 'x√°c nh·∫≠n' ƒë·ªÉ ho√†n t·∫•t."
        
        return "Tr∆∞·ªùng kh√¥ng h·ª£p l·ªá. B·∫°n c√≥ th·ªÉ s·ª≠a: s·ªë l∆∞·ª£ng, t√™n, sƒët, ƒë·ªãa ch·ªâ"

    def _finalize_order(self, session_id: str, context: dict) -> str:
        """Ho√†n t·∫•t v√† l∆∞u ƒë∆°n h√†ng"""
        try:
            if context.get('order_type') == 'multi':
                # üî• FIX: T·∫°o 1 ƒë∆°n duy nh·∫•t v·ªõi note chi ti·∫øt
                # T√≠nh t·ªïng ti·ªÅn v√† t·∫°o description
                items_description = []
                total_quantity = 0
                
                for item in context['order_items']:
                    items_description.append(f"{item['title']} x{item['quantity']}")
                    total_quantity += item['quantity']
                
                # T·∫°o 1 order v·ªõi book_id ƒë·∫ßu ti√™n, note ch·ª©a full info
                first_item = context['order_items'][0]
                order_data = {
                    'customer_name': context['customer_name'],
                    'phone': context['phone'],
                    'address': context['address'],
                    'book_id': first_item['book_id'],
                    'quantity': total_quantity,
                    'note': ' + '.join(items_description)  # Note: "ƒê·∫Øc Nh√¢n T√¢m x2 + Nh√† gi·∫£ kim x3"
                }
                
                order_id = self.db.create_order(order_data)
                
                # Hi·ªÉn th·ªã chi ti·∫øt c√°c s√°ch
                items_text = ""
                for i, item in enumerate(context['order_items'], 1):
                    subtotal = item['price'] * item['quantity']
                    items_text += f"  {i}. {item['title']} x{item['quantity']} = {subtotal:,.0f}ƒë\n"
                
                self.dialog_manager.clear_session(session_id)
                return (f"‚úÖ **ƒê·∫∂T H√ÄNG TH√ÄNH C√îNG!**\n\n"
                        f"M√£ ƒë∆°n h√†ng: #{order_id}\n\n"
                        f"üì¶ Chi ti·∫øt:\n{items_text}"
                        f"üí∞ T·ªïng ti·ªÅn: {context['total_price']:,.0f}ƒë\n"
                        f"üë§ Ng∆∞·ªùi nh·∫≠n: {context['customer_name']}\n"
                        f"üìû SƒêT: {context['phone']}\n"
                        f"üìç ƒê·ªãa ch·ªâ: {context['address']}\n\n"
                        f"Ch√∫ng t√¥i s·∫Ω li√™n h·ªá v·ªõi b·∫°n ƒë·ªÉ x√°c nh·∫≠n.\n"
                        f"C·∫£m ∆°n b·∫°n ƒë√£ mua s√°ch t·∫°i BookStore! üéâ")
            else:
                # ƒê∆°n s√°ch ƒë∆°n
                order_data = {
                    'customer_name': context['customer_name'],
                    'phone': context['phone'],
                    'address': context['address'],
                    'book_id': context['book_id'],
                    'quantity': context['quantity']
                }
                order_id = self.db.create_order(order_data)
                total = context['book_price'] * context['quantity']
                self.dialog_manager.clear_session(session_id)
                return (f"‚úÖ **ƒê·∫∂T H√ÄNG TH√ÄNH C√îNG!**\n\n"
                        f"M√£ ƒë∆°n h√†ng: #{order_id}\n"
                        f"üìö S√°ch: {context['book_title']}\n"
                        f"üî¢ S·ªë l∆∞·ª£ng: {context['quantity']} cu·ªën\n"
                        f"üí∞ T·ªïng ti·ªÅn: {total:,.0f}ƒë\n\n"
                        f"Ch√∫ng t√¥i s·∫Ω li√™n h·ªá v·ªõi b·∫°n qua s·ªë {context['phone']} ƒë·ªÉ x√°c nh·∫≠n.\n"
                        f"C·∫£m ∆°n b·∫°n ƒë√£ mua s√°ch t·∫°i BookStore! üéâ")
        except Exception as e:
            print(f"Error khi t·∫°o ƒë∆°n: {e}")
            return "C√≥ l·ªói khi t·∫°o ƒë∆°n h√†ng, vui l√≤ng th·ª≠ l·∫°i sau."

    # ---------------- Helper validation / parsing ----------------
    def _normalize_and_validate_quantity(self, quantity, max_stock: int) -> Optional[int]:
        """Ch·∫•p nh·∫≠n int, chu·ªói s·ªë, ho·∫∑c None. Tr·∫£ v·ªÅ int h·ª£p l·ªá ho·∫∑c None."""
        if quantity is None:
            return None
        
        if isinstance(quantity, str):
            quantity = quantity.strip()
            if quantity.isdigit():
                try:
                    q = int(quantity)
                except Exception:
                    return None
            else:
                nums = re.findall(r"\d+", quantity)
                q = int(nums[0]) if nums else None
        elif isinstance(quantity, int):
            q = quantity
        else:
            try:
                q = int(quantity)
            except Exception:
                return None

        if not isinstance(q, int) or q <= 0:
            return None
        if q > max_stock:
            return None
        return q

    def _validate_name(self, name):
        if not name:
            return None
        s = str(name).strip()
        if len(s) < 2:
            return None
        return s

    def _validate_phone(self, phone):
        if not phone:
            return None
        
        phone_str = str(phone).strip()
        # L·∫•y to√†n b·ªô ch·ªØ s·ªë trong chu·ªói
        digits = re.findall(r"\d+", phone_str)
        phone_only = ''.join(digits)
        
        # Ki·ªÉm tra ƒë·ªô d√†i h·ª£p l·ªá
        if len(phone_only) not in [10, 11]:
            return None
        
        # B·∫Øt bu·ªôc b·∫Øt ƒë·∫ßu b·∫±ng s·ªë 0
        if not phone_only.startswith("0"):
            return None
        
        # Ki·ªÉm tra to√†n s·ªë
        if not phone_only.isdigit():
            return None
        
        return phone_only


    def _validate_address(self, address):
        if not address:
            return None
        addr = str(address).strip()
        if len(addr) < 5:
            return None
        return addr

    def _extract_phone_from_message(self, message):
        match = re.search(r"(\d{10,11})", message)
        return match.group() if match else None

    def _extract_quantity_from_message(self, message, max_stock):
        numbers = re.findall(r"\d+", message)
        for num_str in numbers:
            try:
                num = int(num_str)
                if 1 <= num <= max_stock:
                    return num
            except ValueError:
                continue
        return None

    def _handle_unknown(self) -> str:
        return ("Xin l·ªói, t√¥i kh√¥ng hi·ªÉu y√™u c·∫ßu c·ªßa b·∫°n. üòÖ\n"
                "B·∫°n c√≥ th·ªÉ:\n"
                "‚Ä¢ T√¨m s√°ch: 'T√¨m s√°ch [t√™n s√°ch]'\n"
                "‚Ä¢ ƒê·∫∑t s√°ch: 'T√¥i mu·ªën mua [t√™n s√°ch]'\n"
                "‚Ä¢ ƒê·∫∑t nhi·ªÅu s√°ch: 'Mua 2 ƒë·∫Øc nh√¢n t√¢m v√† 3 nh√† gi·∫£ kim'\n"
                "‚Ä¢ Xem danh s√°ch: 'C√≥ nh·ªØng s√°ch g√¨'")